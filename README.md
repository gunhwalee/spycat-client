# Spy Cat

**Spy Cat**은 사용자가 보유 중인 서버의 트래픽과 에러를 시각화해주는 웹사이트입니다.  
**Spy Cat**에서 자신의 서버를 등록하고, 간단한 미들웨어 함수를 서버 소스코드에 추가해 다양한 정보를 쉽게 시각화된 차트로 확인할 수 있습니다.

<br>

## 목차

- [Motivation](#motivation)
- [Schedule](#schedule)
- [Tech Stacks](#tech-stacks)
- [Challenges](#challenges)
- [Links](#links)

<br>

## Motivation

이번 프로젝트의 목표는 '**현재 사용할 수 있는 MERN STACK을 다듬고 잘 활용해 실제와 같은 서비스를 구현해 보자**'였습니다.

프로젝트에서 기술적으로 성장하는 것도 중요했지만 팀 프로젝트 당시 React에 대해 심도 있는 주제를 선정했었습니다. 따라서 개인 프로젝트에서는 새로운 것을 시도하는 것보다 지금 할 수 있는 것들을 더 다듬고 개선하는 것을 중점으로 잡았습니다.

프로젝트 아이디어를 고민하던 중 New Relic에서 서비스하는 옵저버빌리티 플랫폼을 구현함으로써 그동안 배웠던 기술 스택들을 다듬고 개선할 기회라고 생각했습니다.

<br>

## Schedule

2023.04.03 ~ 2023.04.21 : 3주

- 아이디어 기획, Mock up 작업 : 1주
- 프로젝트 개발 : 2주

<br>

## Tech Stacks

Frontend

- React
- Redux
- Redux Toolkit
- Styled Components

Backend

- Node.js
- Express
- MongoDB
- Mongoose

<br>

## Challenges

지금 돌이켜 보면 간단히 해결된 문제였지만 개발 당시 크게 고민했던 부분은 3가지였습니다.

### 1. 어떻게 서버에서 발생한 트래픽과 에러의 정보를 수집할 수 있을까?

<br>

#### 1) 트래픽이란 무엇인가?

<br>

트래픽과 에러의 정보를 수집하기 전 트래픽이 정확히 뭔지 되짚어볼 필요가 있었습니다. 웹사이트 관련 대화를 할 때 트래픽이란 단어를 많이 사용하지만, 대략적인 뜻을 유추해서 사용했지 정확한 뜻은 모르고 있었습니다.

트래픽이란 **웹사이트에 방문한 사람들이 데이터를 주고받은 양**을 뜻하며 이를 나타내는 지표는 아주 다양합니다.

이번 프로젝트의 경우 사용자의 서버에 대한 트래픽을 모니터링하는 것이 목적이기 때문에 분석해야 할 트래픽 정보의 종류를 명확하게 지정할 수 있었습니다.

- 서버에 발생한 총 트래픽
- 요청을 가장 많이 받은 라우팅
- 트래픽이 많은 시간대

에러의 경우 위의 분석 정보를 바탕으로 사용자에게 필요한 세부정보를 추가적으로 제공할 수 있었습니다.

- 에러 타입에 대한 발생 빈도
- 에러가 발생한 상세 시간

<br>

#### 2) 트래픽을 어떻게 수집할 것인가?

<br>

트래픽에 대한 정확한 개념이 잡히고 나니 처음 갖고 있던 의문은 자연스레 해결됐습니다.

데이터를 주고받는다 함은 클라이언트의 요청에 대한 서버의 응답을 나타냅니다. 따라서 트래픽은 서버에 들어오는 요청으로 확인할 수 있었습니다.

애플리케이션의 요청-응답 주기에서 클라이언트의 요청을 훼손하지 않으면서 요청에 들어있는 정보를 별도의 서버에 전송하는 미들웨어 함수를 작성했습니다.

에러 정보 또한 커스텀 에러 핸들러와 동일하게 에러 정보를 서버로 전송하고 다음 에러 핸들러로 넘기는 미들웨어 함수를 작성함으로 쉽게 해결 가능했습니다.

<br>

### 2. 어떻게 데이터를 시각화할것인가?

<br>

차트를 그리는 라이브러리는 많았지만 기술 스택을 다듬고 성장하는 과정이기에 라이브러리 없이 차트를 구현해 보고자 했습니다.

<br>

#### SVG vs Canvas API

<br>

보통 차트를 그릴 경우 `SVG` 또는 `Canvas API`를 많이 이용합니다.  
둘의 장단점을 찾아보며 프로젝트에 알맞은 방법이 무엇인지 고민해 봤습니다.

이번 프로젝트의 경우 차트가 실시간으로 반응하기보다는 차트를 불러온 시점 기준으로 데이터를 정적으로 표현하고자 했습니다. 대신 차트가 렌더링 될 때 애니메이션 효과를 넣으려고 했습니다.

`Canvas API` 보다 `SVG`가 애니메이션 효과를 보다 간단하게 구현할 수 있었습니다. 스크립트가 필요한 `Canvas API`에 비해 `SVG`는 간단한 CSS 만으로 애니메이션 효과를 쉽게 구현 가능했습니다.

또한 일자별 차트에서 특정 날짜를 선택할 경우 상세 차트를 보여주고 싶었습니다.  
따라서 사용자 이벤트에 대한 반응이 간편한 `SVG`를 선택해 차트를 구현해 봤습니다.

<br>

### 3. 어떻게 실사용 서비스처럼 만들 수 있을까?

<br>

프로젝트 이전에 공부를 할 당시에는 내가 작성한 로직이 정상작동하는지에만 관심이 쏠려있었습니다. 그래서 프로젝트를 진행하면서 '실제 사용되는 서비스처럼 웹사이트를 구현해보자'라는 작은 목표를 가지고 진행했습니다.

<br>

#### 1) 사용자 경험(UX)을 적용해 보자

<br>

회원가입이나 로그인 등 클라이언트와 서버 사이의 요청-응답이 발생하는 로직의 경우 대략 1~2초 정도 응답을 기다리는 시간이 필요합니다. 물론 1~2초는 짧은 시간이지만 사용자의 입장에서는 연속된 동작 속에서 약간의 공백을 발견한 느낌이 들법했습니다.

따라서 사용자에게 '이 작업은 어느 정도의 시간이 필요합니다'라는 뜻을 전달해야 했습니다.

서버와 요청을 주고받는 동작에 대해서는 별도의 상태를 만들어 버튼을 비활성화하거나, 로딩 아이콘을 보여주는 등의 간단한 작업으로 사용자 편의성을 제공하고자 했습니다.

<br>

#### 2) 무분별한 서버요청을 차단해 보자

<br>

트래픽과 에러를 수집하는 미들웨어 함수를 `npm`으로 설치해서 사용할 수 있는데, 이는 곧 `npm`을 사용하는 사람이라면 누구나 사용할 수 있다는 걸 의미합니다.

서버의 과부하, DB의 용량 문제 등으로 무분별한 서버 요청을 차단해야겠다는 생각을 했습니다.

부트 캠프 과제를 진행하면서 `passport-github`으로 Github에서 `OAuth`를 사용했던 경험을 떠올려 Spy Cat에 회원가입을 한 사용자들에 한해 APIKEY를 발급하고 이를 통해 무분별한 요청을 걸러낼 수 있었습니다.

<br>

## Links

Deploy

- [Spy Cat](https://spycat.netlify.app)

Github Repositories

- [Frontend](https://github.com/spy-cat-0/spycat-client)
- [Backend](https://github.com/spy-cat-0/spycat-server)
